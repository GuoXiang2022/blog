---
title: os-term
date: 2023-04-16 23:04:08
tags:
    - 操作系统
---

###	原语

原语（Atomic Operation）

计算机进程的控制通常由原语完成。所谓原语，一般是指由若干条指令组成的程序段。用来实现某个特定功能，**在执行过程中不可被中断（原子性）**



###	临界区

临界区指的是一个访问**共用资源**的程序片段，而这些共用资源又无法同时被多个线程访问的特性





###	同步

同步是指在进行某个操作时，必须等待该操作完成后才能进行下一步操作。在同步操作中，通常会使用锁、条件变量等同步机制来控制并发访问共享资源的顺序，以确保程序的正确性。



### 异步

异步是指在进行某个操作时，可以不等待该操作完成，而是立即进行下一步操作。异步操作通常会使用**回调函数**等机制来处理异步操作的结果，以便在操作完成后继续执行后续的任务。



### 竞态条件

竞态条件是指当多个线程同时访问共享资源时，由于缺乏同步机制或同步机制实现不当而导致的不确定行为。竞态条件可能导致程序的输出结果不正确，因此需要使用同步机制来保证线程之间的同步。

### 进程

进程是指在操作系统中运行的一个程序实例，是操作系统对运行中的程序的抽象。包括程序的代码、数据、堆栈、寄存器等信息。每个进程都有自己的**独立地址空间**和运行环境，可以独立运行、分配资源和与其他进程通信。



### 线程

线程是进程中的一条执行路径，每个线程都共享进程的地址空间和其他资源，但拥有独立的程序计数器和栈空间。线程可以并发执行，共享进程的资源和状态，并且可以通过同步机制进行同步和通信。



### 锁

锁是一种同步机制，用于保护共享资源的访问顺序，避免竞态条件的发生。常见的锁包括互斥锁、读写锁、自旋锁等，可以使用pthread_mutex_lock、pthread_rwlock_rdlock等函数来加锁和解锁。



### 条件变量

条件变量是一种同步机制，用于在多个线程之间传递信号，以便线程之间可以等待和唤醒。通常与锁一起使用，可以使用pthread_cond_wait、pthread_cond_signal等函数来等待和唤醒条件变量。



### 信号量

信号量是一种同步机制，用于控制对共享资源的访问，包括二元信号量和计数信号量。可以使用sem_wait、sem_post等函数来对信号量进行加





###	互斥锁

互斥锁（Mutex Lock）是最常见的同步机制，它通过一个互斥对象来保证在任意时刻只有一个线程可以访问共享资源。当一个线程获得了互斥锁之后，其他线程必须等待该线程释放互斥锁之后才能访问共享资源。如果多个线程尝试获取同一个互斥锁，其中只有一个线程可以成功获取到，其他线程将被阻塞。

互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞。

对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。

当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。

![image-20230418203517565](/images/mdpic/image-20230418203517565.png)

所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。

那这个开销成本是什么呢？

会有 [两次线程上下文切换的成本](https://blog.csdn.net/nanhuaibeian/article/details/113887012)





###	自旋锁

自旋锁（Spin Lock）是一种特殊的互斥锁，在获取锁的过程中，如果锁已经被占用，当前线程会进入自旋状态，不断地检查锁是否已经被释放。**自旋锁的好处是可以减少线程的上下文切换开销，因为当锁被占用时，线程不会被阻塞，而是一直自旋等待锁的释放**。自旋锁适用于锁被占用时间很短的情况下，如果锁被占用时间较长，则会导致CPU资源的浪费。

所以，如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。

自旋锁认为：如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞、挂起状态，只需等一等（也叫作自旋），在等待持有锁的线程释放锁后即可立即获取锁，这样就避免了用户线程在内核状态的切换上导致的锁时间消耗。

自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。

需要注意，在单核 CPU 上，**需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）**。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU

在持有锁的线程占用锁时间过长或锁的竞争过于激烈时，线程在自旋过程中会长时间获取不到锁资源，将引起CPU的浪费。
所以在系统中有复杂锁依赖的情况下不适合采用自旋锁



###	自旋锁和互斥锁的区别

最底层的两种就是会互斥锁和自旋锁，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。

加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题

当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：

- 互斥锁加锁失败后，线程会释放 CPU ，给其他线程；
- 自旋锁加锁失败后，线程会忙等待也就是自旋，直到它拿到锁；

**简单来说：当加锁失败时，互斥锁用线程切换来应对，自旋锁则用自旋来应对**



###	读写锁

读写锁（Read-Write Lock）是一种特殊的锁，它允许多个线程同时读取共享资源，但只允许一个线程进行写操作。读写锁可以提高读取操作的并发性，因为多个线程可以同时读取共享资源，而写操作只有一个线程进行。读写锁适用于读取操作远远多于写操作的情况下，**因为读写锁的开销比互斥锁大**，如果读写操作的比例相当，那么使用读写锁反而可能会降低性能。